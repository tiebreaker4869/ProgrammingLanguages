open Hw3
open Hw3types

let test1 = only_lowercase ["aaa"; "/aaa"; "Aaa"; "bbb"; "Bbb"; "1bb"] = ["aaa"; "/aaa"; "bbb"; "1bb"]

let () = assert test1

let test2 = longest_string1 ["aaaa"; "bbb"; "cc"; "ddddd"; "ee"; "fffff"] = "ddddd"

let () = assert test2

let test3 = longest_string2 ["aaaa"; "bbbbb"; "eee"; "ccccc"; "ddd"] = "ccccc"

let () = assert test3

let test4 = longest_string3 ["aaaa"; "bbb"; "cc"; "ddddd"; "ee"; "fffff"] = "ddddd"

let () = assert test4

let test5 = longest_string4 ["aaaa"; "bbbbb"; "eee"; "ccccc"; "ddd"] = "ccccc"

let () = assert test5

let test6 = longest_lowercase ["aaaaa"; "/aaaaaa"; "Bbbbbbbb"; "aaeee"; "bbbbb"] = "aaaaa"

let () = assert test6

let test7 = longest_lowercase ["Aaaa"; "Bbbbb"] = ""

let () = assert test7

let test8 = caps_no_X_string "aabbXccxDD" = "AABBCCDD"

let () = assert test8

let test9 = first_answer (fun i -> if i >= 0 then Some i else None) [-1; -2; 1; 2; 3] = 1

let () = assert test9

let test10 = try let _ = first_answer (fun i -> if i >= 0 then Some i else None) [-1; -2; -3] in false 
with NoAnswer -> true

let () = assert test10

let test11 = all_answers (fun _ -> None) [1; 2; 3; 4] = None

let () = assert test11

let test12 = all_answers (fun x -> Some [x]) [] = Some []

let () = assert test12

let test13 = all_answers (fun x -> if x mod 2 = 0 then None else Some [x]) [1; 2; 3; 4; 5] = Some [1; 3; 5]

let () = assert test13

let p = TupleP [WildcardP;ConstructorP ("test", VariableP "aaaaa") ;TupleP [VariableP "variable"; WildcardP]; ConstantP 17; ConstructorP ("constructor", WildcardP)]

let test14 = count_wildcards p = 3

let () = assert test14

let test15 = count_wild_and_variable_lengths p = 16

let () = assert test15

let test16 = (count_a_var "aaaaa" p = 1) && (count_a_var "variable" p = 1) && (count_a_var "bbb" p = 0)

let () = assert test16

let p_uniq = p

let test17 = check_pat p_uniq

let () = assert test17

let p_duplicate = TupleP [WildcardP;ConstructorP ("test", VariableP "aaaaa") ;TupleP [VariableP "variable"; WildcardP]; ConstantP 17; ConstructorP ("constructor", WildcardP); VariableP "variable"]

let test18 = check_pat p_duplicate = false

let () = assert test18

(* this test case is generated by chatGPT and hand tuned by me.*)
let test_matches () =
  (* Test case 1: Matching a Constant value with ConstantP pattern *)
  assert (matches (Constant 42) (ConstantP 42) = Some []);

  (* Test case 2: Matching a Unit value with UnitP pattern *)
  assert (matches Unit UnitP = Some []);

  (* Test case 3: Matching a Constructor value with ConstructorP pattern *)
  assert (matches (Constructor ("SomeConstructor", Constant 10)) (ConstructorP ("SomeConstructor", ConstantP 10)) = Some []);

  (* Test case 4: Matching a Tuple value with TupleP pattern *)
  let tuple_value = Tuple [Constant 1; Constant 2; Constant 3] in
  let tuple_pattern = TupleP [ConstantP 1; ConstantP 2; ConstantP 3] in
  assert (matches tuple_value tuple_pattern = Some []);

  (* Test case 5: Matching a Constructor value with VariableP pattern *)
  let constructor_value = Constructor ("SomeConstructor", Constant 5) in
  assert (matches constructor_value (VariableP "x") = Some [("x", constructor_value)]);

  (* Test case 6: Matching a value that doesn't match the pattern *)
  assert ((matches (Constant 42) (ConstantP 24)) = None);

  (* Test case 7: Matching a Tuple value with a more complex pattern *)
  let nested_tuple_value = Tuple [Constant 1; Constructor ("C", Constant 2); Tuple [Constant 3; Constant 4]] in
  let complex_pattern = TupleP [ConstantP 1; ConstructorP ("C", VariableP "y"); TupleP [VariableP "z"; VariableP "w"]] in
  assert (matches nested_tuple_value complex_pattern = Some [("y", Constant 2); ("z", Constant 3); ("w", Constant 4)]);

  (* Test case 8: Non-matching ConstructorP pattern with wrong constructor name *)
  assert (matches (Constructor ("DifferentConstructor", Constant 5)) (ConstructorP ("SomeConstructor", ConstantP 5)) = None);

  (* Test case 9: Non-matching ConstructorP pattern with wrong inner pattern *)
  assert (matches (Constructor ("SomeConstructor", Constant 5)) (ConstructorP ("SomeConstructor", ConstantP 10)) = None);

  (* Test case 10: Matching a Tuple value with mismatched TupleP pattern *)
  let mismatched_pattern = TupleP [ConstantP 1; ConstantP 4; ConstantP 3] in
  assert (matches tuple_value mismatched_pattern = None);

  assert (matches (Constant 42) (VariableP "x") = Some [("x", Constant 42)])

let () = test_matches ()

let test_first_match () =
  let patterns = [ConstantP 42; ConstructorP ("C", VariableP "y"); VariableP "x"] in
  
  (* Test case 1: Matching the first pattern (ConstantP 42) *)
  let value1 = Constant 42 in
  assert (first_match value1 patterns = Some []);

  (* Test case 2: Matching the third pattern (VariableP "x") *)
  let value2 = Constant 100 in
  assert (first_match value2 patterns = Some [("x", value2)]);

  (* Test case 3: Matching the second pattern (ConstructorP ("C", VariableP "y")) *)
  let value3 = Constructor ("C", Constant 10) in
  assert (first_match value3 patterns = Some ["y", Constant 10]);

  (* Test case 4: No patterns in the list match the value *)
  let value4 = Tuple [Constant 1; Constant 2] in
  assert (first_match value4 [ConstantP 42; ConstructorP ("constructor", ConstantP 1)] = None)

let () = test_first_match ()

let plst1 = [TupleP [VariableP "x"; VariableP "y"];TupleP [WildcardP; WildcardP]]

let test_type_check_patterns1 = typecheck_patterns [] plst1 = Some (TupleT [AnythingT; AnythingT])

let () = assert test_type_check_patterns1

let plst2 = [TupleP [WildcardP; WildcardP]; TupleP [WildcardP; TupleP [WildcardP; WildcardP]]]

let test_type_check_patterns2 = typecheck_patterns [] plst2 = Some (TupleT [AnythingT; TupleT[AnythingT; AnythingT]])

let () = assert test_type_check_patterns2

let plst3 = [TupleP [ConstructorP ("foo", ConstantP 17); WildcardP]; TupleP [ConstructorP ("bar", WildcardP); VariableP "x"]]

let test_type_check_patterns3 = typecheck_patterns [("foo", "variant", IntT); ("bar", "variant", IntT)] plst3 = Some (TupleT [VariantT "variant"; AnythingT])

let () = assert test_type_check_patterns3

